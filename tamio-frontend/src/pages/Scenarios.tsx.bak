import { useEffect, useState, useRef, useCallback, useMemo } from 'react';
import { useSearchParams, Link } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { NeuroCard, NeuroCardContent, NeuroCardHeader, NeuroCardTitle } from '@/components/ui/neuro-card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  ChartContainer,
  ChartTooltip,
  type ChartConfig,
} from '@/components/ui/chart';
import { ComposedChart, Area, XAxis, YAxis, CartesianGrid, Line, ReferenceDot } from 'recharts';
import {
  Users,
  UserPlus,
  UserMinus,
  TrendingUp,
  TrendingDown,
  Clock,
  Building,
  X,
  Save,
  CheckCircle2,
  ArrowRight,
  Send,
  AlertTriangle,
  Loader2,
  Calendar,
  ExternalLink,
  Sparkles,
  MessageCircle,
  DollarSign,
  FileText,
} from 'lucide-react';
import {
  getScenarios,
  getScenarioSuggestions,
  createScenario,
  buildScenario,
  getScenarioForecast,
  saveScenario,
  deleteScenario,
  getRules,
} from '@/lib/api/scenarios';
import { getClients, getExpenses } from '@/lib/api/data';
import { getForecast } from '@/lib/api/forecast';
import { sendChatMessageStreaming, formatConversationHistory } from '@/lib/api/tami';
import type {
  Scenario,
  ScenarioType,
  ScenarioSuggestion,
  ScenarioComparisonResponse,
  ForecastResponse,
  Client,
  ExpenseBucket,
  FinancialRule,
  ChatMode,
  SuggestedAction,
} from '@/lib/api/types';
import { cn } from '@/lib/utils';
import ReactMarkdown from 'react-markdown';

// ============================================================================
// Types
// ============================================================================

interface DisplayMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  mode?: ChatMode;
  suggestedActions?: SuggestedAction[];
  isStreaming?: boolean;
}

interface CollaboratorAvatar {
  id: string;
  name: string;
  initials: string;
  color: string;
  weekNumber?: number;
}

// ============================================================================
// Configuration
// ============================================================================

const scenarioTypeConfig: Record<ScenarioType, { label: string; icon: React.ElementType; description: string }> = {
  client_loss: { label: 'Client Loss', icon: UserMinus, description: 'Model losing a client' },
  client_gain: { label: 'Client Gain', icon: UserPlus, description: 'Model gaining a new client' },
  client_change: { label: 'Client Change', icon: Users, description: 'Model upsell/downsell' },
  hiring: { label: 'Hiring', icon: UserPlus, description: 'Model adding headcount' },
  firing: { label: 'Firing', icon: UserMinus, description: 'Model reducing headcount' },
  contractor_gain: { label: 'Contractor Gain', icon: Building, description: 'Model adding a contractor' },
  contractor_loss: { label: 'Contractor Loss', icon: Building, description: 'Model losing a contractor' },
  increased_expense: { label: 'Increased Expense', icon: TrendingUp, description: 'Model expense increase' },
  decreased_expense: { label: 'Decreased Expense', icon: TrendingDown, description: 'Model expense reduction' },
  payment_delay_in: { label: 'Payment Delay (In)', icon: Clock, description: 'Model delayed client payment' },
  payment_delay_out: { label: 'Payment Delay (Out)', icon: Clock, description: 'Model delayed vendor payment' },
};

const chartConfig = {
  base: { label: 'Base Forecast', color: 'var(--chart-1)' },
  scenario: { label: 'Scenario Forecast', color: 'var(--lime)' },
  buffer: { label: 'Cash Buffer', color: 'var(--tomato)' },
} satisfies ChartConfig;

// Mock collaborators for demo
const MOCK_COLLABORATORS: CollaboratorAvatar[] = [
  { id: '1', name: 'You', initials: 'M', color: 'bg-coral' },
  { id: '2', name: 'Sara', initials: 'S', color: 'bg-blue-500', weekNumber: 5 },
  { id: '3', name: 'CFO', initials: 'C', color: 'bg-emerald-500' },
];

// ============================================================================
// Utility Functions
// ============================================================================

const formatCurrency = (value: number | string) => {
  const num = typeof value === 'string' ? parseFloat(value) : value;
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(num);
};

const formatCompactCurrency = (value: number) => {
  if (Math.abs(value) >= 1000000) {
    return `$${(value / 1000000).toFixed(1)}M`;
  }
  if (Math.abs(value) >= 1000) {
    return `$${Math.round(value / 1000)}K`;
  }
  return formatCurrency(value);
};

// ============================================================================
// Suggested Prompt Type
// ============================================================================

interface SuggestedPrompt {
  id: string;
  label: string;
  query: string;
  icon: 'alert' | 'scenario' | 'forecast' | 'client';
  priority: 'high' | 'medium' | 'low';
  sourceType?: 'alert' | 'suggestion' | 'forecast';
  sourceId?: string;
}

// ============================================================================
// TAMI Chat Inline Component (Below Forecast)
// ============================================================================

interface TAMIChatInlineProps {
  userId: string;
  selectedWeek: number | null;
  forecastData: ForecastResponse | null;
  suggestions?: ScenarioSuggestion[];
  clients?: Client[];
}

function TAMIChatInline({ userId, selectedWeek, forecastData, suggestions = [], clients = [] }: TAMIChatInlineProps) {
  const [messages, setMessages] = useState<DisplayMessage[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Generate suggested prompts based on forecast data, alerts, and scenarios
  const suggestedPrompts: SuggestedPrompt[] = useMemo(() => {
    const prompts: SuggestedPrompt[] = [];

    // Add prompts from forecast data
    if (forecastData?.summary) {
      const lowestWeek = forecastData.summary.lowest_cash_week;
      const lowestAmount = forecastData.summary.lowest_cash_amount
        ? formatCompactCurrency(parseFloat(forecastData.summary.lowest_cash_amount))
        : null;

      if (lowestWeek && lowestAmount) {
        prompts.push({
          id: 'forecast-low',
          label: `Why does Week ${lowestWeek} dip to ${lowestAmount}?`,
          query: `Explain why Week ${lowestWeek} shows a cash dip to ${lowestAmount}`,
          icon: 'forecast',
          priority: 'high',
          sourceType: 'forecast',
        });
      }
    }

    // Add prompts from scenario suggestions (linked to alerts)
    suggestions.forEach((suggestion, index) => {
      if (prompts.length >= 3) return;
      if (suggestion.source_alert_id) {
        prompts.push({
          id: `alert-${suggestion.source_alert_id}`,
          label: suggestion.name,
          query: suggestion.name,
          icon: 'alert',
          priority: suggestion.priority === 'high' ? 'high' : 'medium',
          sourceType: 'alert',
          sourceId: suggestion.source_alert_id,
        });
      } else if (index < 2) {
        prompts.push({
          id: `suggestion-${index}`,
          label: suggestion.name,
          query: suggestion.name,
          icon: 'scenario',
          priority: suggestion.priority === 'high' ? 'high' : 'medium',
          sourceType: 'suggestion',
        });
      }
    });

    // Add client-related prompts for high-concentration clients
    const totalClientIncome = clients.reduce((sum, client) => {
      const amount = parseFloat(client.billing_config?.amount || '0');
      return sum + amount;
    }, 0);

    clients.forEach((client) => {
      if (prompts.length >= 3) return;
      const clientAmount = parseFloat(client.billing_config?.amount || '0');
      const concentration = totalClientIncome > 0 ? (clientAmount / totalClientIncome) * 100 : 0;

      if (concentration > 25) {
        prompts.push({
          id: `client-${client.id}`,
          label: `What if ${client.name} pays late?`,
          query: `What happens if ${client.name} pays 30 days late?`,
          icon: 'client',
          priority: concentration > 40 ? 'high' : 'medium',
          sourceType: 'suggestion',
        });
      }
    });

    // Default fallback prompts to ensure we always have 3
    const defaultPrompts: SuggestedPrompt[] = [
      {
        id: 'default-payroll',
        label: 'Can I make payroll if payments are delayed?',
        query: 'Can I make payroll if no payments come in for 2 weeks?',
        icon: 'alert',
        priority: 'high',
        sourceType: 'suggestion',
      },
      {
        id: 'default-hiring',
        label: 'Can we afford to hire someone new?',
        query: 'Can we afford to hire a new employee at $6,000/month?',
        icon: 'scenario',
        priority: 'medium',
        sourceType: 'suggestion',
      },
      {
        id: 'default-client-loss',
        label: 'What if we lose our biggest client?',
        query: 'What happens if we lose our biggest client?',
        icon: 'client',
        priority: 'medium',
        sourceType: 'suggestion',
      },
    ];

    // Fill in with defaults if we don't have 3 prompts
    let defaultIndex = 0;
    while (prompts.length < 3 && defaultIndex < defaultPrompts.length) {
      const defaultPrompt = defaultPrompts[defaultIndex];
      // Only add if we don't already have a similar prompt
      if (!prompts.some(p => p.id === defaultPrompt.id)) {
        prompts.push(defaultPrompt);
      }
      defaultIndex++;
    }

    // Sort by priority and return exactly 3
    return prompts
      .sort((a, b) => {
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      })
      .slice(0, 3);
  }, [forecastData, suggestions, clients]);

  // Auto-scroll to bottom when messages change
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages]);

  // Handle week selection from chart
  useEffect(() => {
    if (selectedWeek !== null && forecastData) {
      const week = forecastData.weeks.find(w => w.week_number === selectedWeek);
      if (week) {
        const newMessage: DisplayMessage = {
          role: 'assistant',
          content: `**Week ${selectedWeek}** shows:\n- Starting: ${formatCurrency(week.starting_balance)}\n- Cash In: +${formatCurrency(week.cash_in)}\n- Cash Out: -${formatCurrency(week.cash_out)}\n- Ending: ${formatCurrency(week.ending_balance)}\n\nWould you like me to explain what's driving this week's numbers?`,
          timestamp: new Date(),
          mode: 'explain_forecast',
          suggestedActions: [
            { label: 'Why does this happen?', action: 'none', tool_name: null, tool_args: null },
            { label: 'Show mitigation options', action: 'none', tool_name: null, tool_args: null },
            { label: 'Run scenario', action: 'none', tool_name: null, tool_args: null },
          ],
        };
        setMessages(prev => [...prev, newMessage]);
      }
    }
  }, [selectedWeek, forecastData]);

  const handleSendMessage = useCallback(async () => {
    if (!inputMessage.trim() || isLoading) return;

    const userMessage: DisplayMessage = {
      role: 'user',
      content: inputMessage,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setIsLoading(true);

    // Add streaming assistant message
    const streamingMessage: DisplayMessage = {
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      isStreaming: true,
    };
    setMessages(prev => [...prev, streamingMessage]);

    try {
      await sendChatMessageStreaming(
        {
          user_id: userId,
          message: inputMessage,
          conversation_history: formatConversationHistory(messages),
          active_scenario_id: null,
        },
        // onChunk
        (chunk) => {
          setMessages(prev => {
            const updated = [...prev];
            const lastIdx = updated.length - 1;
            if (updated[lastIdx]?.isStreaming) {
              updated[lastIdx] = {
                ...updated[lastIdx],
                content: updated[lastIdx].content + chunk,
              };
            }
            return updated;
          });
        },
        // onDone
        (event) => {
          setMessages(prev => {
            const updated = [...prev];
            const lastIdx = updated.length - 1;
            if (updated[lastIdx]?.isStreaming) {
              updated[lastIdx] = {
                ...updated[lastIdx],
                isStreaming: false,
                mode: event.mode,
                suggestedActions: event.ui_hints?.suggested_actions,
              };
            }
            return updated;
          });
          setIsLoading(false);
        },
        // onError
        (error) => {
          console.error('Chat error:', error);
          setMessages(prev => {
            const updated = [...prev];
            const lastIdx = updated.length - 1;
            if (updated[lastIdx]?.isStreaming) {
              updated[lastIdx] = {
                ...updated[lastIdx],
                content: 'Sorry, I encountered an error. Please try again.',
                isStreaming: false,
              };
            }
            return updated;
          });
          setIsLoading(false);
        }
      );
    } catch (error) {
      console.error('Failed to send message:', error);
      setIsLoading(false);
    }
  }, [inputMessage, isLoading, userId, messages]);

  const handleSuggestedAction = (action: SuggestedAction) => {
    setInputMessage(action.label);
    setTimeout(() => handleSendMessage(), 100);
  };

  const handleSuggestedPrompt = (prompt: SuggestedPrompt) => {
    // Directly set the user message and trigger send
    const userMessage: DisplayMessage = {
      role: 'user',
      content: prompt.query,
      timestamp: new Date(),
    };
    setMessages([userMessage]);
    setInputMessage('');
    setIsLoading(true);

    // Add streaming assistant message
    const streamingMessage: DisplayMessage = {
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      isStreaming: true,
    };
    setMessages(prev => [...prev, streamingMessage]);

    // Send the message
    sendChatMessageStreaming(
      {
        user_id: userId,
        message: prompt.query,
        conversation_history: [],
        active_scenario_id: null,
      },
      (chunk) => {
        setMessages(prev => {
          const updated = [...prev];
          const lastIdx = updated.length - 1;
          if (updated[lastIdx]?.isStreaming) {
            updated[lastIdx] = {
              ...updated[lastIdx],
              content: updated[lastIdx].content + chunk,
            };
          }
          return updated;
        });
      },
      (event) => {
        setMessages(prev => {
          const updated = [...prev];
          const lastIdx = updated.length - 1;
          if (updated[lastIdx]?.isStreaming) {
            updated[lastIdx] = {
              ...updated[lastIdx],
              isStreaming: false,
              mode: event.mode,
              suggestedActions: event.ui_hints?.suggested_actions,
            };
          }
          return updated;
        });
        setIsLoading(false);
      },
      (error) => {
        console.error('Chat error:', error);
        setMessages(prev => {
          const updated = [...prev];
          const lastIdx = updated.length - 1;
          if (updated[lastIdx]?.isStreaming) {
            updated[lastIdx] = {
              ...updated[lastIdx],
              content: 'Sorry, I encountered an error. Please try again.',
              isStreaming: false,
            };
          }
          return updated;
        });
        setIsLoading(false);
      }
    );
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // Get icon for suggested prompt
  const getPromptIcon = (iconType: SuggestedPrompt['icon']) => {
    switch (iconType) {
      case 'alert':
        return <AlertTriangle className="w-4 h-4" />;
      case 'scenario':
        return <Sparkles className="w-4 h-4" />;
      case 'forecast':
        return <TrendingDown className="w-4 h-4" />;
      case 'client':
        return <Building className="w-4 h-4" />;
      default:
        return <MessageCircle className="w-4 h-4" />;
    }
  };

  // Get gradient and styling based on priority for glassmorphic cards
  const getPromptGradient = (priority: SuggestedPrompt['priority']) => {
    switch (priority) {
      case 'high':
        return {
          gradient: 'bg-gradient-to-br from-tomato/20 via-tomato/10 to-transparent',
          border: 'border-tomato/30',
          iconBg: 'bg-tomato/20 text-tomato',
          hoverBorder: 'hover:border-tomato/50',
        };
      case 'medium':
        return {
          gradient: 'bg-gradient-to-br from-amber-400/20 via-amber-300/10 to-transparent',
          border: 'border-amber-400/30',
          iconBg: 'bg-amber-400/20 text-amber-600',
          hoverBorder: 'hover:border-amber-400/50',
        };
      case 'low':
        return {
          gradient: 'bg-gradient-to-br from-lime/30 via-lime/15 to-transparent',
          border: 'border-lime/40',
          iconBg: 'bg-lime/30 text-lime-dark',
          hoverBorder: 'hover:border-lime/60',
        };
      default:
        return {
          gradient: 'bg-gradient-to-br from-white/60 via-white/30 to-transparent',
          border: 'border-white/40',
          iconBg: 'bg-white/40 text-gunmetal/60',
          hoverBorder: 'hover:border-white/60',
        };
    }
  };

  return (
    <div className="rounded-2xl bg-white/30 backdrop-blur-xl border border-white/40 p-6 shadow-lg shadow-black/5">
      {/* Header */}
      <div className="flex items-center gap-3 mb-5">
        <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-coral to-coral/70 flex items-center justify-center shadow-md">
          <span className="text-white text-base font-bold">T</span>
        </div>
        <div>
          <h3 className="text-base font-semibold text-gunmetal">Chat with TAMI</h3>
          <p className="text-xs text-muted-foreground">Ask about forecast details or explore scenarios</p>
        </div>
      </div>

      {/* Suggested Prompts - shown when no messages */}
      {messages.length === 0 && suggestedPrompts.length > 0 && (
        <div className="mb-5">
          <p className="text-xs text-muted-foreground mb-3 font-medium tracking-wide uppercase">Suggested questions based on your forecast:</p>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            {suggestedPrompts.map((prompt) => {
              const styles = getPromptGradient(prompt.priority);
              return (
                <button
                  key={prompt.id}
                  onClick={() => handleSuggestedPrompt(prompt)}
                  disabled={isLoading}
                  className={cn(
                    'relative flex items-center gap-3 p-4 rounded-xl text-left transition-all duration-300 group disabled:opacity-50',
                    'backdrop-blur-sm border',
                    styles.gradient,
                    styles.border,
                    styles.hoverBorder,
                    'hover:shadow-md hover:scale-[1.02]'
                  )}
                >
                  <div className={cn(
                    'w-9 h-9 rounded-lg flex items-center justify-center flex-shrink-0 transition-colors',
                    styles.iconBg
                  )}>
                    {getPromptIcon(prompt.icon)}
                  </div>
                  <span className="text-sm font-medium text-gunmetal/90 group-hover:text-gunmetal line-clamp-2">
                    {prompt.label}
                  </span>
                </button>
              );
            })}
          </div>
        </div>
      )}

      {/* Messages - scrollable area with max height */}
      {messages.length > 0 && (
        <div
          ref={scrollRef}
          className="max-h-[300px] overflow-y-auto mb-5 space-y-3 pr-2"
        >
          {messages.map((message, index) => (
            <div key={index} className={cn('flex', message.role === 'user' ? 'justify-end' : 'justify-start')}>
              <div
                className={cn(
                  'max-w-[80%] rounded-2xl px-4 py-3 text-sm',
                  message.role === 'user'
                    ? 'bg-gunmetal text-white'
                    : 'bg-white/60 backdrop-blur-sm border border-white/40 text-gunmetal'
                )}
              >
                {message.role === 'assistant' ? (
                  <div className="prose prose-sm max-w-none">
                    <ReactMarkdown>{message.content}</ReactMarkdown>
                    {message.isStreaming && (
                      <span className="inline-flex items-center gap-1 ml-1">
                        <span className="w-1.5 h-1.5 bg-coral rounded-full animate-bounce [animation-delay:-0.3s]" />
                        <span className="w-1.5 h-1.5 bg-coral rounded-full animate-bounce [animation-delay:-0.15s]" />
                        <span className="w-1.5 h-1.5 bg-coral rounded-full animate-bounce" />
                      </span>
                    )}
                  </div>
                ) : (
                  message.content
                )}

                {/* Suggested Actions */}
                {message.suggestedActions && message.suggestedActions.length > 0 && !message.isStreaming && (
                  <div className="flex flex-wrap gap-2 mt-3">
                    {message.suggestedActions.map((action, actionIndex) => (
                      <button
                        key={actionIndex}
                        onClick={() => handleSuggestedAction(action)}
                        className={cn(
                          'px-3 py-1.5 rounded-full text-xs font-medium transition-all',
                          actionIndex === 0
                            ? 'bg-coral text-white hover:bg-coral/90'
                            : 'bg-white/80 backdrop-blur-sm border border-white/40 text-gunmetal hover:bg-white'
                        )}
                      >
                        {action.label}
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Input */}
      <div className="flex items-center gap-3">
        <Input
          ref={inputRef}
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Ask about any week or scenario..."
          className="flex-1 bg-white/50 backdrop-blur-sm border-white/40 focus:border-coral/40 focus:ring-coral/20"
          disabled={isLoading}
        />
        <Button
          onClick={handleSendMessage}
          disabled={!inputMessage.trim() || isLoading}
          className="bg-gradient-to-r from-coral to-coral/80 hover:from-coral/90 hover:to-coral/70 text-white px-6 shadow-md"
        >
          {isLoading ? <Loader2 className="w-4 h-4 animate-spin" /> : <Send className="w-4 h-4" />}
        </Button>
      </div>
    </div>
  );
}

// ============================================================================
// Floating Notification Component
// ============================================================================

interface FloatingNotificationProps {
  show: boolean;
  onDismiss: () => void;
  onAction: () => void;
}

function FloatingNotification({ show, onDismiss, onAction }: FloatingNotificationProps) {
  if (!show) return null;

  return (
    <div className="fixed bottom-6 right-6 z-50 animate-in slide-in-from-bottom-5 fade-in duration-300">
      <div className="bg-white/70 backdrop-blur-xl rounded-2xl shadow-xl border border-white/40 p-4 max-w-sm">
        <div className="flex items-start gap-3">
          <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-lime/40 to-lime/20 flex items-center justify-center flex-shrink-0">
            <TrendingUp className="w-5 h-5 text-lime-dark" />
          </div>
          <div className="flex-1">
            <h4 className="font-semibold text-gunmetal text-sm">Quick heads up</h4>
            <p className="text-sm text-muted-foreground mt-1">
              HealthTech just paid their invoice early! This improves your Week 5 buffer by $8K.
            </p>
            <div className="flex items-center gap-2 mt-3">
              <Button size="sm" onClick={onAction} className="bg-gradient-to-r from-coral to-coral/80 hover:from-coral/90 hover:to-coral/70 text-white text-xs shadow-sm">
                View Update
              </Button>
              <Button size="sm" variant="ghost" onClick={onDismiss} className="text-xs text-muted-foreground hover:text-gunmetal">
                Later
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// Main Scenarios Component
// ============================================================================

export default function Scenarios() {
  const { user } = useAuth();
  const [searchParams] = useSearchParams();

  // Data state
  const [savedScenarios, setSavedScenarios] = useState<Scenario[]>([]);
  const [suggestions, setSuggestions] = useState<ScenarioSuggestion[]>([]);
  const [baseForecast, setBaseForecast] = useState<ForecastResponse | null>(null);
  const [clients, setClients] = useState<Client[]>([]);
  const [expenses, setExpenses] = useState<ExpenseBucket[]>([]);
  const [rules, setRules] = useState<FinancialRule[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [savedScenariosDialogOpen, setSavedScenariosDialogOpen] = useState(false);
  const [appliedScenarios, setAppliedScenarios] = useState<string[]>([]);

  // Chart interaction state
  const [selectedWeek, setSelectedWeek] = useState<number | null>(null);
  const [timePeriod, setTimePeriod] = useState<'13' | '26' | '52'>('13');

  // Scenario builder state
  const [scenarioType, setScenarioType] = useState<ScenarioType | ''>('');
  const [scenarioName, setScenarioName] = useState('');
  const [activeScenario, setActiveScenario] = useState<Scenario | null>(null);
  const [comparison, setComparison] = useState<ScenarioComparisonResponse | null>(null);

  // Form fields
  const [selectedClient, setSelectedClient] = useState('');
  const [selectedExpense, setSelectedExpense] = useState('');
  const [effectiveDate, setEffectiveDate] = useState('');
  const [amount, setAmount] = useState('');
  const [delayDays, setDelayDays] = useState('');
  const [isBuildingScenario, setIsBuildingScenario] = useState(false);
  const [buildError, setBuildError] = useState<string | null>(null);

  // Notification state
  const [showNotification, setShowNotification] = useState(false);

  // Show notification after 3 seconds (demo)
  useEffect(() => {
    const timer = setTimeout(() => {
      setShowNotification(true);
    }, 3000);
    return () => clearTimeout(timer);
  }, []);

  // Fetch initial data
  useEffect(() => {
    if (!user) return;

    const fetchData = async () => {
      try {
        const [scenariosData, suggestionsData, forecastData, clientsData, expensesData, rulesData] = await Promise.all([
          getScenarios(user.id, 'saved').catch(() => []),
          getScenarioSuggestions(user.id).catch(() => ({ suggestions: [] })),
          getForecast(user.id).catch(() => null),
          getClients(user.id).catch(() => []),
          getExpenses(user.id).catch(() => []),
          getRules(user.id).catch(() => []),
        ]);

        setSavedScenarios(scenariosData);
        setSuggestions(suggestionsData.suggestions || []);
        setBaseForecast(forecastData);
        setClients(clientsData.filter((c) => c.status === 'active'));
        setExpenses(expensesData);
        setRules(rulesData);

        const typeParam = searchParams.get('type');
        if (typeParam && typeParam in scenarioTypeConfig) {
          setScenarioType(typeParam as ScenarioType);
        }
      } catch (error) {
        console.error('Failed to fetch scenario data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [user, searchParams]);

  // Handlers
  const handleStartScenario = (type: ScenarioType, suggestion?: ScenarioSuggestion) => {
    setScenarioType(type);
    setScenarioName(suggestion?.name || `${scenarioTypeConfig[type].label} Scenario`);
    setComparison(null);

    if (suggestion?.prefill_params) {
      const params = suggestion.prefill_params as Record<string, unknown>;
      if (params.client_id) setSelectedClient(params.client_id as string);
      if (params.effective_date) setEffectiveDate(params.effective_date as string);
      if (params.amount) setAmount(String(params.amount));
      if (params.delay_days) setDelayDays(String(params.delay_days));
    } else {
      setSelectedClient('');
      setEffectiveDate('');
      setAmount('');
      setDelayDays('');
    }
  };

  const handleBuildScenario = async () => {
    if (!user || !scenarioType) return;

    setIsBuildingScenario(true);
    setBuildError(null);

    const buildScopeConfig = () => {
      if (selectedClient) return { client_id: selectedClient };
      if (selectedExpense) return { bucket_id: selectedExpense };
      return {};
    };

    try {
      const scenario = await createScenario({
        user_id: user.id,
        name: scenarioName,
        scenario_type: scenarioType,
        entry_path: 'user_defined',
        scope_config: buildScopeConfig(),
        parameters: {
          effective_date: effectiveDate || new Date().toISOString().split('T')[0],
          amount,
          delay_days: delayDays ? parseInt(delayDays) : undefined,
        },
      });

      setActiveScenario(scenario);
      await buildScenario(scenario.id);
      const comparisonData = await getScenarioForecast(scenario.id);
      setComparison(comparisonData);
    } catch (error) {
      console.error('Failed to build scenario:', error);
      setBuildError(error instanceof Error ? error.message : 'Failed to build scenario. Please try again.');
    } finally {
      setIsBuildingScenario(false);
    }
  };

  const handleSaveScenario = async () => {
    if (!activeScenario) return;

    try {
      await saveScenario(activeScenario.id);
      setSavedScenarios([...savedScenarios, { ...activeScenario, status: 'saved' }]);
      setActiveScenario(null);
      setComparison(null);
      resetForm();
    } catch (error) {
      console.error('Failed to save scenario:', error);
    }
  };

  const handleDiscardScenario = async () => {
    if (activeScenario) {
      await deleteScenario(activeScenario.id).catch(() => {});
    }
    setActiveScenario(null);
    setComparison(null);
    resetForm();
  };

  const resetForm = () => {
    setScenarioType('');
    setScenarioName('');
    setSelectedClient('');
    setSelectedExpense('');
    setEffectiveDate('');
    setAmount('');
    setDelayDays('');
  };

  const toggleAppliedScenario = (scenarioId: string) => {
    setAppliedScenarios((prev) =>
      prev.includes(scenarioId) ? prev.filter((id) => id !== scenarioId) : [...prev, scenarioId]
    );
  };

  const handleChartClick = (weekNumber: number) => {
    setSelectedWeek(weekNumber);
  };

  // Helper functions
  const getInferredClientAmount = (): string | null => {
    if (scenarioType !== 'client_loss' || !selectedClient) return null;
    const client = clients.find((c) => c.id === selectedClient);
    if (!client?.billing_config?.amount) return null;
    return client.billing_config.amount;
  };

  const getAmountLabel = (): string => {
    switch (scenarioType) {
      case 'client_gain':
      case 'hiring':
      case 'contractor_gain':
      case 'increased_expense':
        return 'Monthly Amount ($)';
      case 'client_change':
        return 'Change Amount (+/-)';
      case 'firing':
      case 'contractor_loss':
      case 'decreased_expense':
        return 'Monthly Reduction ($)';
      default:
        return 'Amount ($)';
    }
  };

  const requiresAmountInput = (): boolean => {
    return [
      'client_gain',
      'hiring',
      'contractor_gain',
      'increased_expense',
      'client_change',
      'firing',
      'contractor_loss',
      'decreased_expense',
    ].includes(scenarioType);
  };

  // Generate suggested scenarios
  const generateSuggestedScenarios = (): ScenarioSuggestion[] => {
    const generatedSuggestions: ScenarioSuggestion[] = [];
    const totalClientIncome = clients.reduce((sum, client) => {
      const amount = parseFloat(client.billing_config?.amount || '0');
      return sum + amount;
    }, 0);

    // Priority #1 - Payroll coverage
    generatedSuggestions.push({
      scenario_type: 'payment_delay_in',
      name: 'Can I make payroll if no payments come in?',
      description: 'See if payroll is covered even if all expected payments are delayed by 2 weeks.',
      prefill_params: { delay_days: 14, apply_to_all: true },
      priority: 'high',
      source_alert_id: 'alert-payroll-1',
      source_detection_type: 'PAYROLL_SAFETY',
    });

    // Check for high concentration clients
    clients.forEach((client) => {
      const clientAmount = parseFloat(client.billing_config?.amount || '0');
      const concentration = totalClientIncome > 0 ? (clientAmount / totalClientIncome) * 100 : 0;

      if (concentration > 30) {
        generatedSuggestions.push({
          scenario_type: 'payment_delay_in',
          name: `What if ${client.name} pays 30 days late?`,
          description: `${client.name} is ${concentration.toFixed(0)}% of revenue. Check buffer impact if payment is delayed.`,
          prefill_params: { client_id: client.id, delay_days: 30 },
          priority: 'medium',
        });
      }
    });

    // Default scenarios
    const defaultScenarios: ScenarioSuggestion[] = [
      {
        scenario_type: 'client_loss',
        name: 'What if RetailCo Rebrand pays 30 days late?',
        description: 'Based on historical payment delays',
        prefill_params: {},
        priority: 'medium',
      },
    ];

    while (generatedSuggestions.length < 3 && defaultScenarios.length > 0) {
      const defaultScenario = defaultScenarios.shift();
      if (defaultScenario) {
        generatedSuggestions.push(defaultScenario);
      }
    }

    return generatedSuggestions.slice(0, 3);
  };

  const allSuggestions = suggestions.length > 0 ? suggestions : generateSuggestedScenarios();

  // Calculate metrics from backend data (consistent with Dashboard)
  const hasData = baseForecast && baseForecast.weeks && baseForecast.weeks.length > 0;

  const bufferRule = rules.find((r) => r.rule_type === 'minimum_cash_buffer');
  const targetBufferMonths = (bufferRule?.threshold_config as { months?: number })?.months || 3;

  const totalCashOut = baseForecast?.summary?.total_cash_out
    ? parseFloat(baseForecast.summary.total_cash_out)
    : 0;
  const totalCashIn = baseForecast?.summary?.total_cash_in
    ? parseFloat(baseForecast.summary.total_cash_in)
    : 0;
  const monthlyExpenses = totalCashOut / 3;
  const monthlyIncome = totalCashIn / 3;
  const bufferAmount = monthlyExpenses * targetBufferMonths;

  // Get values from backend summary
  const cashPosition = parseFloat(baseForecast?.starting_cash || '0');
  const runwayWeeks = baseForecast?.summary?.runway_weeks || 0;
  const lowestCashWeek = baseForecast?.summary?.lowest_cash_week || 0;
  const lowestCashAmount = parseFloat(baseForecast?.summary?.lowest_cash_amount || '0');

  // Suppress unused variable warnings - available for future use
  void runwayWeeks;
  void lowestCashWeek;
  void lowestCashAmount;

  // Calculate buffer coverage in months (consistent with Dashboard)
  const bufferCoverageMonths = monthlyExpenses > 0
    ? Math.max(0, lowestCashAmount / monthlyExpenses)
    : (lowestCashAmount > 0 ? 99 : 0);

  // Determine risk level based on buffer coverage
  // High: less than 1 month, Medium: 1-3 months, Low: 3+ months
  const riskLevel = !hasData ? 'Unknown'
    : bufferCoverageMonths < 1 ? 'High'
    : bufferCoverageMonths < targetBufferMonths ? 'Medium'
    : 'Low';

  // Chart data
  const chartData = comparison
    ? comparison.base_forecast?.weeks.map((baseWeek, index) => {
        const scenarioWeek = comparison.scenario_forecast?.weeks[index];
        return {
          week: `Week ${baseWeek.week_number}`,
          weekNumber: baseWeek.week_number,
          base: parseFloat(baseWeek.ending_balance),
          scenario: scenarioWeek ? parseFloat(scenarioWeek.ending_balance) : parseFloat(baseWeek.ending_balance),
          buffer: bufferAmount,
          cashIn: parseFloat(baseWeek.cash_in),
          cashOut: parseFloat(baseWeek.cash_out),
        };
      })
    : baseForecast?.weeks.map((week) => ({
        week: `Week ${week.week_number}`,
        weekNumber: week.week_number,
        base: parseFloat(week.ending_balance),
        scenario: null,
        buffer: bufferAmount,
        cashIn: parseFloat(week.cash_in),
        cashOut: parseFloat(week.cash_out),
      })) || [];

  // Quick scenario templates
  const quickTemplates = [
    { icon: DollarSign, label: 'What if RetailCo pays 30 days late?', type: 'payment_delay_in' as ScenarioType },
    { icon: Users, label: 'Can we afford to hire 2 people?', type: 'hiring' as ScenarioType },
    { icon: FileText, label: 'What if we lose our biggest client?', type: 'client_loss' as ScenarioType },
  ];

  if (isLoading) {
    return (
      <div className="space-y-6">
        <Skeleton className="h-12 w-64" />
        <Skeleton className="h-20 w-full" />
        <div className="grid grid-cols-3 gap-5">
          <Skeleton className="h-40" />
          <Skeleton className="h-40" />
          <Skeleton className="h-40" />
        </div>
        <Skeleton className="h-[500px]" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <h1 className="text-2xl font-bold tracking-tight text-gunmetal">Forecast & Scenarios</h1>

      {/* Collaborative Header Bar */}
      <NeuroCard className="p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <span className="text-sm text-muted-foreground">Active now</span>
            <div className="flex -space-x-2">
              {MOCK_COLLABORATORS.map((collab) => (
                <Avatar key={collab.id} className="w-8 h-8 border-2 border-white">
                  <AvatarFallback className={cn(collab.color, 'text-white text-xs font-medium')}>
                    {collab.initials}
                  </AvatarFallback>
                </Avatar>
              ))}
            </div>
          </div>
          <span className="text-sm text-muted-foreground">Last updated: 2 minutes ago</span>
        </div>
      </NeuroCard>

      {/* KPI Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-5">
        {/* Current Position */}
        <NeuroCard className="p-6">
          <div className="text-center">
            <div className="text-4xl font-bold text-gunmetal">{formatCompactCurrency(cashPosition)}</div>
            <div className="text-sm font-medium text-muted-foreground mt-2">Current Position</div>
            <div className="flex items-center justify-center gap-1 mt-2">
              <TrendingUp className="h-3.5 w-3.5 text-lime-dark" />
              <span className="text-xs font-medium text-lime-dark">+5.9% (30D)</span>
            </div>
          </div>
        </NeuroCard>

        {/* Income (30D) */}
        <NeuroCard className="p-6">
          <div className="text-center">
            <div className="text-4xl font-bold text-lime-dark">
              {!hasData ? '--' : `+${formatCompactCurrency(monthlyIncome)}`}
            </div>
            <div className="text-sm font-medium text-muted-foreground mt-2">Income (30D)</div>
            <div className={cn(
              'text-xs font-medium mt-2',
              !hasData ? 'text-muted-foreground' : 'text-lime-dark'
            )}>
              {!hasData ? 'No forecast data' : 'Expected inflows'}
            </div>
          </div>
        </NeuroCard>

        {/* Expenses (30D) */}
        <NeuroCard className="p-6">
          <div className="text-center">
            <div className="text-4xl font-bold text-tomato">
              {!hasData ? '--' : `-${formatCompactCurrency(monthlyExpenses)}`}
            </div>
            <div className="text-sm font-medium text-muted-foreground mt-2">Expenses (30D)</div>
            <div className={cn(
              'text-xs font-medium mt-2',
              !hasData ? 'text-muted-foreground' : 'text-tomato'
            )}>
              {!hasData ? 'No forecast data' : 'Expected outflows'}
            </div>
          </div>
        </NeuroCard>
      </div>

      {/* Forecast Chart - Full Width */}
      <NeuroCard>
        <NeuroCardHeader className="pb-4">
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-4">
              <NeuroCardTitle>13-Week Forecast</NeuroCardTitle>
              {/* Tab-style controls */}
              <div className="flex items-center gap-1 p-1 bg-gray-100 rounded-lg">
                <button className="px-3 py-1.5 text-sm font-medium text-muted-foreground hover:text-gunmetal rounded-md flex items-center gap-1.5">
                  <Calendar className="w-3.5 h-3.5" />
                  Events
                </button>
                <button className="px-3 py-1.5 text-sm font-medium bg-white text-gunmetal rounded-md shadow-sm flex items-center gap-1.5">
                  <Sparkles className="w-3.5 h-3.5 text-coral" />
                  Scenarios
                </button>
                <button className="px-3 py-1.5 text-sm font-medium text-muted-foreground hover:text-gunmetal rounded-md flex items-center gap-1.5">
                  <MessageCircle className="w-3.5 h-3.5" />
                  Notes
                </button>
              </div>
            </div>
            <div className="flex items-center gap-3">
              {/* Time Period Selector */}
              <Select value={timePeriod} onValueChange={(v) => setTimePeriod(v as '13' | '26' | '52')}>
                <SelectTrigger className="w-[120px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="13">13 weeks</SelectItem>
                  <SelectItem value="26">26 weeks</SelectItem>
                  <SelectItem value="52">52 weeks</SelectItem>
                </SelectContent>
              </Select>

              {/* Apply Saved Scenarios Button */}
              <Dialog open={savedScenariosDialogOpen} onOpenChange={setSavedScenariosDialogOpen}>
                <DialogTrigger asChild>
                  <Button variant="outline" className="bg-lime/20 border-lime hover:bg-lime/30">
                    Apply Saved Scenarios
                    {appliedScenarios.length > 0 && (
                      <Badge className="ml-2 bg-lime text-foreground">{appliedScenarios.length}</Badge>
                    )}
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Saved Scenarios</DialogTitle>
                  </DialogHeader>
                  <div className="space-y-2 mt-4">
                    {savedScenarios.length === 0 ? (
                      <p className="text-sm text-muted-foreground text-center py-4">
                        No saved scenarios yet. Build and save a scenario to see it here.
                      </p>
                    ) : (
                      savedScenarios.map((scenario) => (
                        <div
                          key={scenario.id}
                          className={cn(
                            'flex items-center justify-between p-3 rounded-lg border cursor-pointer transition-colors',
                            appliedScenarios.includes(scenario.id) ? 'bg-lime/10 border-lime' : 'hover:bg-muted'
                          )}
                          onClick={() => toggleAppliedScenario(scenario.id)}
                        >
                          <div>
                            <p className="font-medium">{scenario.name}</p>
                            <p className="text-sm text-muted-foreground">
                              {scenarioTypeConfig[scenario.scenario_type]?.label}
                            </p>
                          </div>
                          {appliedScenarios.includes(scenario.id) && <CheckCircle2 className="h-5 w-5 text-lime" />}
                        </div>
                      ))
                    )}
                  </div>
                </DialogContent>
              </Dialog>
            </div>
          </div>
        </NeuroCardHeader>
        <NeuroCardContent>
          {/* Legend */}
          <div className="flex items-center justify-center gap-6 mb-4 text-sm">
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-[var(--chart-1)]" />
              <span>Base Forecast</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-lime" />
              <span>Scenario Forecast</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-6 h-0.5 border-b-2 border-dashed border-tomato" />
              <span>Cash Buffer (Minimum)</span>
            </div>
          </div>

          {/* Chart */}
          <ChartContainer config={chartConfig} className="h-[400px] w-full">
            <ComposedChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
              onClick={(data) => {
                if (data?.activePayload?.[0]?.payload?.weekNumber) {
                  handleChartClick(data.activePayload[0].payload.weekNumber);
                }
              }}
            >
              <CartesianGrid vertical={false} strokeDasharray="3 3" />
              <XAxis dataKey="week" tickLine={false} axisLine={false} tickMargin={8} tick={{ fontSize: 12 }} />
              <YAxis
                tickFormatter={(value) => `$${(value / 1000).toFixed(0)}K`}
                tickLine={false}
                axisLine={false}
                tick={{ fontSize: 12 }}
              />
              <ChartTooltip
                cursor={{ fill: 'rgba(0,0,0,0.05)' }}
                content={({ active, payload, label }) => {
                  if (active && payload && payload.length) {
                    const data = payload[0].payload;
                    return (
                      <div className="rounded-xl border bg-white/90 backdrop-blur-sm p-4 shadow-xl">
                        <p className="font-semibold mb-2">{label}</p>
                        <div className="space-y-1 text-sm">
                          <div className="flex justify-between gap-4">
                            <span className="text-muted-foreground">Position:</span>
                            <span className="font-medium">{formatCurrency(data.base)}</span>
                          </div>
                          <div className="flex justify-between gap-4">
                            <span className="text-lime-dark">Income:</span>
                            <span className="font-medium text-lime-dark">+{formatCurrency(data.cashIn)}</span>
                          </div>
                          <div className="flex justify-between gap-4">
                            <span className="text-tomato">Expenses:</span>
                            <span className="font-medium text-tomato">-{formatCurrency(data.cashOut)}</span>
                          </div>
                        </div>
                        <p className="text-xs text-muted-foreground mt-3 pt-2 border-t">Click to ask TAMI about this week</p>
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <defs>
                <linearGradient id="fillBase" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="var(--chart-1)" stopOpacity={0.8} />
                  <stop offset="95%" stopColor="var(--chart-1)" stopOpacity={0.1} />
                </linearGradient>
                <linearGradient id="fillScenario" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="var(--lime)" stopOpacity={0.8} />
                  <stop offset="95%" stopColor="var(--lime)" stopOpacity={0.1} />
                </linearGradient>
              </defs>
              <Area type="monotone" dataKey="base" stroke="var(--chart-1)" strokeWidth={2} fill="url(#fillBase)" fillOpacity={0.4} />
              {comparison && (
                <Area type="monotone" dataKey="scenario" stroke="var(--lime)" strokeWidth={2} fill="url(#fillScenario)" fillOpacity={0.4} />
              )}
              {bufferAmount > 0 && (
                <Line type="monotone" dataKey="buffer" stroke="#ef4444" strokeDasharray="8 4" strokeWidth={2} dot={false} activeDot={false} />
              )}
              {/* Collaborator markers on chart */}
              {MOCK_COLLABORATORS.filter(c => c.weekNumber).map((collab) => {
                const weekData = chartData.find(d => d.weekNumber === collab.weekNumber);
                if (!weekData) return null;
                return (
                  <ReferenceDot
                    key={collab.id}
                    x={weekData.week}
                    y={weekData.base}
                    r={8}
                    fill={collab.color.replace('bg-', '#')}
                    stroke="white"
                    strokeWidth={2}
                  />
                );
              })}
            </ComposedChart>
          </ChartContainer>

          {/* Chart footer hint */}
          <div className="text-center mt-4 text-sm text-muted-foreground flex items-center justify-center gap-2">
            <Sparkles className="w-4 h-4" />
            Interactive forecast chart
            <span className="mx-2">|</span>
            Click anywhere to ask TAMI about that week
            <ArrowRight className="w-4 h-4" />
          </div>
        </NeuroCardContent>
      </NeuroCard>

      {/* TAMI Chat Section - Inline below forecast */}
      <TAMIChatInline
        userId={user?.id || ''}
        selectedWeek={selectedWeek}
        forecastData={baseForecast}
        suggestions={allSuggestions}
        clients={clients}
      />

      {/* Suggested Scenarios Section */}
      <NeuroCard>
        <NeuroCardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <NeuroCardTitle>Suggested Scenarios</NeuroCardTitle>
            <Badge className="bg-lime/20 text-lime-dark border-lime/30">{allSuggestions.length} ready to run</Badge>
          </div>
        </NeuroCardHeader>
        <NeuroCardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {allSuggestions.slice(0, 3).map((suggestion, index) => {
              const priority = suggestion.priority || 'medium';
              const hasAlert = !!suggestion.source_alert_id;

              return (
                <div
                  key={index}
                  onClick={() => handleStartScenario(suggestion.scenario_type, suggestion)}
                  className={cn(
                    'group cursor-pointer p-5 rounded-2xl bg-white border-l-4 transition-all duration-300',
                    'hover:shadow-lg hover:scale-[1.02]',
                    priority === 'high' ? 'border-l-tomato' : priority === 'medium' ? 'border-l-amber-500' : 'border-l-lime'
                  )}
                >
                  {/* Priority Badge */}
                  <div className="mb-3">
                    <Badge
                      variant="outline"
                      className={cn(
                        'text-xs font-semibold uppercase tracking-wide',
                        priority === 'high'
                          ? 'bg-tomato/10 border-tomato/30 text-tomato'
                          : priority === 'medium'
                            ? 'bg-amber-500/10 border-amber-500/30 text-amber-600'
                            : 'bg-lime/10 border-lime/30 text-lime-dark'
                      )}
                    >
                      {priority === 'high' ? 'High Risk' : priority === 'medium' ? 'Medium Risk' : 'Low Risk'}
                    </Badge>
                  </div>

                  {/* Scenario Question */}
                  <h3 className="font-semibold text-gunmetal mb-2 group-hover:text-gunmetal/80">
                    {suggestion.name}
                  </h3>

                  {/* Impact */}
                  <p className="text-sm text-muted-foreground mb-3">
                    <span className="font-medium text-gunmetal">Impact:</span> -2.1 weeks runway
                    <br />
                    Buffer depletes by Week 4
                  </p>

                  {/* Alert Link or Context */}
                  {hasAlert ? (
                    <div className="flex items-center gap-2 text-xs text-amber-600 mb-4">
                      <AlertTriangle className="w-3.5 h-3.5" />
                      <span>This scenario links to "Payroll underfunded" alert</span>
                      <Link to="/action-monitor" className="text-coral hover:underline flex items-center gap-1">
                        View Alert <ExternalLink className="w-3 h-3" />
                      </Link>
                    </div>
                  ) : index === 1 ? (
                    <div className="flex items-center gap-2 text-xs text-blue-600 mb-4">
                      <Avatar className="w-4 h-4">
                        <AvatarFallback className="bg-blue-500 text-white text-[8px]">S</AvatarFallback>
                      </Avatar>
                      <span>Sara ran this scenario 2 hours ago</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-2 text-xs text-muted-foreground mb-4">
                      <TrendingDown className="w-3.5 h-3.5" />
                      <span>Based on historical payment delays</span>
                    </div>
                  )}

                  {/* Run Button */}
                  <Button className="w-full bg-coral hover:bg-coral/90 text-white">
                    Run Scenario
                    <ArrowRight className="w-4 h-4 ml-2" />
                  </Button>
                </div>
              );
            })}
          </div>
        </NeuroCardContent>
      </NeuroCard>

      {/* Test Your Own Scenario Section */}
      <NeuroCard>
        <NeuroCardHeader className="pb-4">
          <NeuroCardTitle>Test Your Own Scenario</NeuroCardTitle>
        </NeuroCardHeader>
        <NeuroCardContent>
              {/* Scenario Result Summary */}
              {comparison && (
                <div className="mb-6 p-4 bg-gunmetal/5 rounded-lg border border-gunmetal/10">
                  <div className="flex items-center justify-between mb-3">
                    <div>
                      <p className="text-xs text-muted-foreground uppercase tracking-wide mb-1">Overall Scenario Impact</p>
                      <h3 className="font-semibold text-lg">{scenarioName}</h3>
                    </div>
                    <Badge variant={riskLevel === 'Low' ? 'default' : 'destructive'} className="text-sm px-3 py-1">
                      {riskLevel === 'Low' ? 'Buffer Safe' : 'Buffer At Risk'}
                    </Badge>
                  </div>
                  <div className="grid grid-cols-3 gap-4 text-sm">
                    <div>
                      <p className="text-muted-foreground">Impact at Week 13</p>
                      <p
                        className={cn(
                          'text-2xl font-bold',
                          parseFloat(comparison.scenario_forecast.weeks[12]?.ending_balance || '0') -
                            parseFloat(comparison.base_forecast.weeks[12]?.ending_balance || '0') >= 0
                            ? 'text-lime'
                            : 'text-tomato'
                        )}
                      >
                        {formatCurrency(
                          parseFloat(comparison.scenario_forecast.weeks[12]?.ending_balance || '0') -
                            parseFloat(comparison.base_forecast.weeks[12]?.ending_balance || '0')
                        )}
                      </p>
                    </div>
                    <div>
                      <p className="text-muted-foreground">Base Position</p>
                      <p className="text-xl font-semibold">
                        {formatCurrency(comparison.base_forecast.weeks[12]?.ending_balance || '0')}
                      </p>
                    </div>
                    <div>
                      <p className="text-muted-foreground">Scenario Position</p>
                      <p className="text-xl font-semibold">
                        {formatCurrency(comparison.scenario_forecast.weeks[12]?.ending_balance || '0')}
                      </p>
                    </div>
                  </div>
                  <div className="flex gap-3 mt-4">
                    <Button onClick={handleSaveScenario} className="bg-lime text-foreground hover:bg-lime/90">
                      <Save className="h-4 w-4 mr-2" />
                      Save Scenario
                    </Button>
                    <Button variant="destructive" onClick={handleDiscardScenario}>
                      <X className="h-4 w-4 mr-2" />
                      Discard
                    </Button>
                  </div>
                </div>
              )}

              {/* Form */}
              {!comparison && (
                <div className="space-y-4 p-4 bg-white/60 rounded-xl border border-white/40">
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <div className="space-y-2">
                      <Label>Scenario Name</Label>
                      <Input
                        value={scenarioName}
                        onChange={(e) => setScenarioName(e.target.value)}
                        placeholder="Client Loss Scenario"
                      />
                    </div>

                    <div className="space-y-2">
                      <Label>Scenario Type</Label>
                      <Select value={scenarioType} onValueChange={(v) => setScenarioType(v as ScenarioType)}>
                        <SelectTrigger>
                          <SelectValue placeholder="Select type" />
                        </SelectTrigger>
                        <SelectContent>
                          {Object.entries(scenarioTypeConfig).map(([type, config]) => (
                            <SelectItem key={type} value={type}>
                              {config.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>

                    <div className="space-y-2">
                      <Label>Effective Date</Label>
                      <Input type="date" value={effectiveDate} onChange={(e) => setEffectiveDate(e.target.value)} />
                    </div>

                    {/* Client selector */}
                    {['client_loss', 'client_change', 'payment_delay_in'].includes(scenarioType) && (
                      <div className="space-y-2">
                        <Label>Client Name</Label>
                        <Select value={selectedClient} onValueChange={setSelectedClient}>
                          <SelectTrigger>
                            <SelectValue placeholder="Select client" />
                          </SelectTrigger>
                          <SelectContent>
                            {clients.map((client) => (
                              <SelectItem key={client.id} value={client.id}>
                                {client.name}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                    )}

                    {/* Expense selector */}
                    {scenarioType === 'payment_delay_out' && (
                      <div className="space-y-2">
                        <Label>Expense / Vendor</Label>
                        <Select value={selectedExpense} onValueChange={setSelectedExpense}>
                          <SelectTrigger>
                            <SelectValue placeholder="Select expense" />
                          </SelectTrigger>
                          <SelectContent>
                            {expenses.map((expense) => (
                              <SelectItem key={expense.id} value={expense.id}>
                                {expense.name} ({formatCurrency(parseFloat(expense.monthly_amount))}/mo)
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                    )}

                    {/* Inferred amount for client_loss */}
                    {scenarioType === 'client_loss' && selectedClient && (
                      <div className="space-y-2">
                        <Label>Monthly Impact</Label>
                        <div className="h-10 px-3 py-2 border rounded-md bg-muted text-muted-foreground flex items-center">
                          {getInferredClientAmount()
                            ? formatCurrency(parseFloat(getInferredClientAmount()!))
                            : 'Select a client'}
                        </div>
                      </div>
                    )}

                    {/* Amount input */}
                    {requiresAmountInput() && (
                      <div className="space-y-2">
                        <Label>{getAmountLabel()}</Label>
                        <Input
                          type="number"
                          value={amount}
                          onChange={(e) => setAmount(e.target.value)}
                          placeholder="10000"
                        />
                      </div>
                    )}

                    {/* Delay days */}
                    {['payment_delay_in', 'payment_delay_out'].includes(scenarioType) && (
                      <div className="space-y-2">
                        <Label>Delay (days)</Label>
                        <Input
                          type="number"
                          value={delayDays}
                          onChange={(e) => setDelayDays(e.target.value)}
                          placeholder="14"
                        />
                      </div>
                    )}
                  </div>

                  {buildError && (
                    <div className="p-3 bg-destructive/10 border border-destructive/20 rounded-md text-sm text-destructive">
                      {buildError}
                    </div>
                  )}

                  <div className="flex gap-3">
                    <Button variant="outline" onClick={handleDiscardScenario} disabled={isBuildingScenario}>
                      Cancel
                    </Button>
                    <Button
                      onClick={handleBuildScenario}
                      disabled={isBuildingScenario || !scenarioType}
                      className="bg-primary"
                    >
                      {isBuildingScenario ? 'Building...' : 'Build Scenario'}
                    </Button>
                  </div>
                </div>
              )}
        </NeuroCardContent>
      </NeuroCard>

      {/* Floating Notification */}
      <FloatingNotification
        show={showNotification}
        onDismiss={() => setShowNotification(false)}
        onAction={() => {
          setShowNotification(false);
          // Could navigate to update or refresh data
        }}
      />
    </div>
  );
}
